= Quarkus Temporal

include::./includes/attributes.adoc[]

A Quarkus extension that lets you utilize https://temporal.io/[Temporal], orchestrating both mission-critical and mainstream workloads.

== Installation

If you want to use this extension, you need to add the `io.quarkiverse.temporal:quarkus-temporal` extension first to your build file.

For instance, with Maven, add the following dependency to your POM file:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.quarkiverse.temporal</groupId>
    <artifactId>quarkus-temporal</artifactId>
    <version>{project-version}</version>
</dependency>
----

[#getting-started]
== Getting Started

Activities and workflows are automatically detected. Simply implement an interface annotated with `@ActivityInterface` or `@WorkflowInterface`.

=== Create a Workflow

[source,java]
----
@WorkflowInterface
public interface SendEmailWorkflow {

    @WorkflowMethod
    public void run(WorkflowData data);

    @QueryMethod
    public EmailDetails details();
}
----

The following workflow definition will be automatically bound to the default worker:

[source,java]
----
public class SendEmailWorkflowImpl implements SendEmailWorkflow {
    @Override
    public void run(WorkflowData data) {
    }
}
----

It is possible to associate the workflow with one or more named workers instead by annotating it with @TemporalWorkflow:

[source,java]
----
@TemporalWorkflow(workers = "named-worker")
public class SendEmailWorkflowImpl implements SendEmailWorkflow {
    @Override
    public void run(WorkflowData data) {
    }
}
----

If you don't have control over the workflow class, it is also possible to bind it with a worker using the workflow-classes configuration property of the worker.

[source,properties]
----
quarkus.temporal.worker.namedWorker.workflow-classes[0]: io.quarkiverse.temporal.SendEmailWorkflowImpl
----

In this case, it will not be associated with the default worker unless you also bind it explicitely:

[source,properties]
----
quarkus.temporal.worker.workflow-classes[0]: io.quarkiverse.temporal.SendEmailWorkflowImpl
----

Each worker can have at most one implementation of a given workflow, but a workflow can have implementations across multiple workers.

Workflows are not provided as CDI beans because dependency injection into workflow instances is strongly discouraged. Injecting dependencies into workflow instances can lead to changes that are incompatible with persisted histories, resulting in `NonDeterministicException` errors. To provide external configuration to a workflow in a deterministic way, use a Local Activity that returns the configuration to the workflow. Dependency injection into activity instances is allowed, ensuring that the configuration is persisted into the history and remains consistent during replay.

=== Create an Activity

[source,java]
----
@ActivityInterface
public interface SendEmailActivities {
    @ActivityMethod
    public String sendEmail(EmailDetails details);
}
----

The following activity definition will be added automatically to the default worker:

[source,java]
----
public class SendEmailActivitiesImpl implements SendEmailActivities {

    @Inject // <1>
    AgroalDataSource defaultDataSource;

    @Override
    public String sendEmail(EmailDetails details) {

    }
}
----

<1> CDI Dependency Injection is allowed in activity definition.

It is possible to associate the activity with one or more named workers instead by annotating it with @TemporalActivity:

[source,java]
----
@TemporalActivity(workers = "named-worker")
public class SendEmailActivitiesImpl implements SendEmailActivities {
    @Override
    public String sendEmail(EmailDetails details) {

    }
}
----

If you don't have control over the activity class, it is also possible to bind it with a worker using the activity-classes configuration property of the worker:

[source,properties]
----
quarkus.temporal.worker.namedWorker.activity-classes[0]: io.quarkiverse.temporal.SendEmailActivitiesImpl
----

In this case, it will not be associated with the default worker unless you also bind it explicitely:

[source,properties]
----
quarkus.temporal.worker.activity-classes[0]: io.quarkiverse.temporal.SendEmailActivitiesImpl
----

Similarly, each worker can have at most one implementation of a given activity, but an activity can have implementations across multiple workers.


=== Using the client

[source,java]
----
public class MyService {

    @Inject
    WorkflowClient client; // <1>

    public void startSubscription(WorkflowData data) {

        WorkflowOptions options = WorkflowOptions.newBuilder()
                .setWorkflowId(data.getEmail())
                .setTaskQueue("<default>") // <2>
                .build();

        SendEmailWorkflow workflow = client.newWorkflowStub(SendEmailWorkflow.class, options);
        WorkflowClient.start(workflow::run,data);

    }

}
----

<1> The client can be injected as a CDI bean
<2> The default worker queue is <default>. for named worker, use the name of the worker

=== Stub Injection

It is also possible to inject a workflow stub directly using the TemporalWorkflowStub qualifier:

[source,java]
----
public class MyService {

    @Inject
    @TemporalWorkflowStub(workflowId = "send-email")
    SendEmailWorkflow workflow;

    public void startSubscription(WorkflowData data) {
        workflow.run(data);
    }

}
----

If the workflow is bound to multiple workers, the worker parameter is required:

[source,java]
----
public class MyService {

    @Inject
    @TemporalWorkflowStub(worker = "<default>", workflowId = "send-email")
    SendEmailWorkflow workflow;

    public void startSubscription(WorkflowData data) {
        workflow.run(data);
    }

}
----

The workflowId can be set at runtime by dynamically resolving the stub bean:

[source,java]
----
public class MyService {

    public void startSubscription(WorkflowData data) {
        SendEmailWorkflow workflow = CDI.current()
                .select(SimpleWorkflow.class, new TemporalWorkflowStub.Literal("<default>", "dynamicWorkflowId")).get();
        workflow.run(data);
    }

}
----



[[extension-configuration-reference]]
== Extension Configuration Reference

include::includes/quarkus-temporal.adoc[leveloffset=+1, opts=optional]